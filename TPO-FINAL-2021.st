SimpleButtonMorph subclass: #BotonAccion2	instanceVariableNames: 'fecha bloque contenedor'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!BotonAccion2 methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/2/2021 11:42'!mouseUp: unEvento"Este m√©todo se ejecuta cuando se produce un evento, como un click sobre el mouse y suliberaci√≥n. Como mouseAction mantiene un bloque, se le envia el mensaje value para que seejecuten las acciones indicadas en el bloque."super mouseUp: unEvento.bloque value.! !!BotonAccion2 methodsFor: 'as yet unclassified' stamp: 'nm 6/27/2016 12:42'!mouseAction: unBloque"Se guarda en la variable bloque el bloque que se recibe como par√°metro, que indica que acci√≥n se ejecutar√° cuando haya una acci√≥n sobre el mouse. Al utilizarlo en conjunto conFechaVisual las acciones posibles son incrementar y decrementar aplicados sobre una instancia de FechaModelo, y como se indica en el m√©todo initialize de FechaVisual, unBloque se instancia con [miFecha incrementar:10] y [miFecha decrementar:2]"^bloque := unBloque.! !OrderedCollection subclass: #Cola	instanceVariableNames: 'ultimo cantElem'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Cola methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 12:53'!inicializarCola"Inicializa una cola como orderedCollection"ultimo := nil.cantElem := 0.! !!Cola methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 12:57'!sacarPrimeroCola	"Saca el primer elemento en la Cola"	||	cantElem = 0 	ifTrue: [^'LA COLA YA ESTA VACIA']	ifFalse:[	self removeFirst.		cantElem := cantElem -1.]! !!Cola methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 12:53'!ponerEnCola: unElem	"Ingresa un elemento en la Cola"	||	self addLast: unElem.	cantElem := cantElem +1.	ultimo := unElem.	! !!Cola methodsFor: 'as yet unclassified' stamp: 'Anonymous 1/29/2021 19:39'!extraerElementoCola| elem |elem:= self at:1.^elem. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cola class	instanceVariableNames: ''!!Cola class methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 13:04'!crearCola	"Usa una ordered collection como Cola"	|cola|	cola := self new.	cola inicializarCola.	^cola.! !Object subclass: #Lector	instanceVariableNames: 'notacionEntrada valoresX colResultadosX h cantPuntos colOperaciones'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 21:15'!inicializarLector	cantPuntos := 1.	colResultadosX := OrderedCollection new.	valoresX := OrderedCollection new.	colOperaciones := OrderedCollection new.	colOperaciones add: Simple crearSimple. 	colOperaciones add: Doble crearDoble.  		! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 10:48'!inicializarLector: unaCadena conX: unValor	"Para inicializar un Lector con la cadena de notacion polaca, y un unico valor de X"	notacionEntrada := unaCadena.	colResultadosX := OrderedCollection new.	valoresX := OrderedCollection new.	valoresX addLast: unValor.	cantPuntos := 1.	h := 0.	colOperaciones := OrderedCollection new.	colOperaciones add: Simple crearSimple.  	colOperaciones add: Doble crearDoble. 			! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 21:11'!añadirValorX: unValorvaloresX add: unValor.! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 11:56'!esNumero: char^char =$. or:(char asciiValue >47 and:(char asciiValue < 58)).! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:44'!inicializarLector: unaCadena inicioIntervalo: unInicio finIntervalo: unFin cantidadPuntos: unaCant	"Para inicializar un Lector con la cadena de notacion polaca, el intervalo y la cantidad de puntos a evaluar"	|puntoActual|	notacionEntrada := unaCadena.	colResultadosX := OrderedCollection new.	valoresX := OrderedCollection new.	cantPuntos := unaCant.	h := unFin-unInicio.	h := h / (cantPuntos -1). "Analizar caso de 1 unico punto"	colOperaciones := OrderedCollection new.	colOperaciones add: Simple crearSimple. 	colOperaciones add: Doble crearDoble.  		puntoActual := unInicio.   [puntoActual >= unFin] whileFalse: [valoresX addLast: puntoActual. puntoActual := (puntoActual + h)].   valoresX addLast: puntoActual. "Para añadir el ultimo punto, que es igual a unFin"	! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 11:09'!operar: pila simbolo: simbolo	|op op2 num1 num2 res|num1:= pila extraerTope.pila sacarTopePila.num2:= pila extraerTope."si el simbolo no es de una operacion simple, pasa a la operacion doble"op:= colOperaciones at: 1.op2:= colOperaciones at: 2.(op verificarSimbolo: simbolo) ifTrue: [res:= op operarSimple: num1 simbolo: simbolo ]. (op2 verificarSimbolo: simbolo) ifTrue: [res:= op2 operarDoble: num1 parametro2: num2 simbolo: simbolo. pila sacarTopePila].pila ponerEnPila: res.^pila ! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 20:10'!getValoresX^valoresX .! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 16:10'!analizarNotacion	"Divide la notacion en distintas operaciones que seran enviadas a la clase Operacion"	|num op  pila|	pila := Pila crearPila.	num := ''.	op:= ''.	notacionEntrada := notacionEntrada, ' '.	"Por cada valor de x va a evaluar el resultado de la notacion de entrada"	valoresX do:[:valorx|		"lee cada caracter de la notacion de entrada y evalua que hacer "  		notacionEntrada do: [:char| 		"si el caracter es un numero, crea un string provisorio para ver si el numero tiene mas de dos sifras"		"si es una x, se reemplaza por el valor de x que se esta evaluando del elemento de valoresX"		"si el valor es otra cosa se guarda en un string provisorio, ya que es un operador o una funcion"		[ self esNumero: char ]value ifTrue:[num:=num, char asString]  			ifFalse:[char=$ ifFalse:				[char=$x ifTrue:[pila ponerEnPila: valorx] ifFalse: [op:= op, char asString] ]].	 "cuando se llega al espacio:			(*) Si hay algo en num, pasa ese string a numero y lo agrega en la pila 			(*) Si hay algo en op, se evalua la operacion con los numeros de la pila"	   	char = $ ifTrue: 			[num = '' ifFalse: [pila ponerEnPila: num asNumber. num:='']. op = '' ifFalse: [self operar: pila simbolo: op. op:='']].				 ].	"el resultado final sera el unico elemento de la pila, se a‚àö¬±ade a la coleccion de resultados y se desapila"	colResultadosX add: pila extraerTope.	pila sacarTopePila .].! !!Lector methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 19:38'!getColResultados^colResultadosX. ! !!Lector methodsFor: 'initialization' stamp: 'Anonymous 2/27/2021 21:04'!setNotacionEntrada: cadenanotacionEntrada := cadena.! !!Lector methodsFor: 'initialization' stamp: 'Anonymous 2/27/2021 21:05'!setCantPuntos: numerocantPuntos:= numero.! !!Lector methodsFor: 'initialization' stamp: 'Anonymous 2/27/2021 21:17'!setValoresX: unInicio finIntervalo: unFin"metodo para añadir los valores de X""por parametro entra el intervalo""tiene que existir una cantidad de puntos antes"|puntoActual|h := unFin-unInicio.h := h / (cantPuntos -1). "Analizar caso de 1 unico punto"puntoActual := unInicio.[puntoActual >= unFin] whileFalse: [valoresX addLast: puntoActual. puntoActual := (puntoActual + h)].valoresX addLast: puntoActual. "Para añadir el ultimo punto, que es igual a unFin"! !!Lector methodsFor: 'initialization' stamp: 'Anonymous 2/27/2021 22:07'!resetColecciones"vuelve a las colecciones de los valores de X y de los resultados en 0""esto sirve para que se puedan ir renovando valores y resultados"colResultadosX := OrderedCollection new.	valoresX := OrderedCollection new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Lector class	instanceVariableNames: ''!!Lector class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 15:48'!crearLector: entrada conX: x	"comment stating purpose of message"	| ret |	ret:= self new.	ret inicializarLector: entrada conX: x.	^ret.! !!Lector class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 20:59'!crearLector	"comment stating purpose of message"	| ret |	ret:= self new.	ret inicializarLector.	^ret.! !!Lector class methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 2/1/2021 16:00'!crearLector: unaCadena inicioIntervalo: unInicio finIntervalo: unFin cantidadPuntos: unaCant	"Constructor de la clase Lector"	|lec| lec := self new.lec inicializarLector: unaCadena inicioIntervalo: unInicio finIntervalo: unFin cantidadPuntos: unaCant.^lec.! !Object subclass: #Operacion	instanceVariableNames: 'param1 resultado colSimbolos'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Operacion methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:47'!verificarSimbolo: unSimbolo|res|"verifica si la simbolo por parametro existe en la coleccion de simbolos"colSimbolos detect: [:sim| sim = unSimbolo] ifFound: [ res:= true ] ifNone: [ res:= false ].^res.! !!Operacion methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 10:13'!inicializarOperacionresultado :=0.param1:=0.colSimbolos := OrderedCollection new.! !!Operacion methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/25/2021 11:38'!cargarUnParametro: par1	"Permite cargar un parametro para las operaciones coseno, seno, tangente, factorial y raiz cuadrada"	||	param1 := par1.! !!Operacion methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 14:16'!getResultado^resultado.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operacion class	instanceVariableNames: ''!!Operacion class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 14:12'!crearOperacion	"creacion de termino"	|term|	term := self new.	term inicializarOperacion. 	^term. ! !Operacion subclass: #Doble	instanceVariableNames: 'param2'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Doble methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/28/2021 18:48'!operarDoble: p1 parametro2: p2 simbolo: simbolo|res sim|param1:= p1.param2:= p2.(simbolo='^') ifTrue: [ resultado:= p2 raisedTo:p1 ]ifFalse: [ sim:= simbolo asSymbol. "dependiendo el simbolo, se hace una operacion""si no encuentra ninguno el programa hara una excepción"resultado:= p2 perform: sim with: p1. ].res:= resultado. ^res. ! !!Doble methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 10:16'!inicializarDobleself inicializarOperacion.colSimbolos add: '+'.colSimbolos add: '-'.colSimbolos add: '*'.colSimbolos add: '/'.colSimbolos add: '^'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Doble class	instanceVariableNames: ''!!Doble class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 10:17'!crearDoble|op|op:= self new.op inicializarDoble.^op.! !Object subclass: #Parser	instanceVariableNames: 'entrada salida colPrioridades fun'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 20:04'!Parentesis: char cola:cola pila1: pila1 pila2: pila2"Si es un parentesis ( , va a verificar si se trata de una funcion o de un parentesis comun""Se da cuenta que es una funcion porque la variable fun tiene contenido""Si es una función, coloca el string fun sobre la pila, con prioridad 3""Si no es función entonces coloca el parentesis en la pila"char=$( ifTrue:[fun='' ifFalse:[pila1 ponerEnPila: fun. pila2 ponerEnPila: 3. fun:=''].pila1 ponerEnPila: $(. pila2 ponerEnPila: 0] "si no es un parentesis (, es uno: )"ifFalse: [ "Cuando encuentra un parentesis )quita todos los elementos de la pila y lo coloca en la cola"	[ pila2 extraerTope >0] whileTrue: [ cola ponerEnCola: ' '. cola ponerEnCola: pila1 extraerTope. pila1 sacarTopePila. pila2 sacarTopePila]. pila1 sacarTopePila. pila2 sacarTopePila. ]! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 17:20'!prioridades: char cola: cola pila1: pila1 pila2: pila2	|numPrioridad topeCola2|"verificamos y extraemos si esta el simbolo pasado por parametro a la colección de prioridades"	colPrioridades do: [:tupla | char = (tupla at:1) ifTrue: [ numPrioridad := (tupla at:2) ] ].topeCola2:= pila2 extraerTope. "el numero de prioridad se va a comparar con este valor""mientras que el numero de prioridad entrante sea menor al cargado en la pila, se añade el contenido de la pila1 a la cola""la pila 1 es la que tiene los simbolos"[numPrioridad < topeCola2] whileTrue:  [cola ponerEnCola: pila1 extraerTope. cola ponerEnCola:' '. pila1 sacarTopePila. pila2 sacarTopePila. topeCola2:= pila2 extraerTope.]. pila1 ponerEnPila: char.pila2 ponerEnPila: numPrioridad.  ! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/2/2021 17:57'!getSalida^salida.! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/2/2021 09:56'!esLetra: char	^char asciiValue > 96 and:(char asciiValue < 122 and:(char asciiValue ~= 120)).! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 20:09'!rpn|cola pila pila2 ret elem|"el metodo RPN se encarga de convertir el string de salida en uno de notacion RPN"cola:= Cola crearCola. "la cola va creando la nueva traduccion"pila:= Pila crearPila. "esta pila almacena funciones y simbolos de operaciones"pila2:= Pila crearPila. "la pila 2 almacena las prioridades de los elementos que ingresan a la pila 1"pila ponerEnPila: 0. 	pila2 ponerEnPila: 0.ret:=''.entrada do: [:char| [self esNumero: char]value ifTrue: [ cola ponerEnCola: char ]. "si es un numero ingresa en la cola"				"si es un simbolo verificamos que prioridad tiene con respecto al proximo de la cola "		  [self esSimbolo: char]value ifTrue: [ cola ponerEnCola:' '.self prioridades: char cola: cola pila1: pila pila2: pila2 ].  					"si es un parentesis ( o ) invoca al metodo parentesis"			[ self esParentesis: char ]value ifTrue: [ self Parentesis: char cola: cola pila1: pila pila2: pila2 ].					"Si el caracter es una letra, se trata de una función"			"Se va completando la variable fun como un string, corta cuando encuentra un parentesis"			[ self esLetra: char ]value ifTrue:[fun:= fun, (char asString)].				].	"Crea el string que retorna"cola do: [:char| ret:= ret, (char asString)].elem:= pila extraerTope."los elementos de la pila de contenidos los agrega al string resultante"[ elem ~= 0. ] whileTrue: 	[ 			ret:= ret, ' ',(pila extraerTope)asString. 		pila sacarTopePila. 		elem:= pila extraerTope. 	].^ret.! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/2/2021 17:56'!getEntrada^entrada.! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:52'!Parentesis: cola pila1: pila1 pila2: pila2"Cuando encuentra un parentesis quita todos los elementos de la pila y lo coloca en la cola"	[ pila2 extraerTope >0] whileTrue: [ cola ponerEnCola: ' '. cola ponerEnCola: pila1 extraerTope. pila1 sacarTopePila. pila2 sacarTopePila]. pila1 sacarTopePila. pila2 sacarTopePila. ! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 20:22'!inicializarParser	"comment stating purpose of message"fun:= ''.colPrioridades := OrderedCollection new.colPrioridades add: #($+ 1).colPrioridades add: #($- 1).colPrioridades add: #($* 2).colPrioridades add: #($/ 2).colPrioridades add: #($^ 2).colPrioridades add: #($!! 3).! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 19:27'!esNumero: char^char=$x or:(char =$. or:(char asciiValue >47 and:(char asciiValue < 58))).  	! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 19:35'!traducirCadena: unaCadena		entrada:= unaCadena.	salida:= self rpn.^salida.! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 19:58'!inicializarParser: unaCadena	"comment stating purpose of message"entrada:= unaCadena.salida:= ''.fun:=''.colPrioridades := OrderedCollection new."la suma y la resta tiene menos prioridad que el resto"colPrioridades add: #($+ 1). colPrioridades add: #($- 1).colPrioridades add: #($* 2). colPrioridades add: #($/ 2).colPrioridades add: #($^ 2).colPrioridades add: #($!! 3).! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 19:39'!esParentesis: char^char=$( or:(char=$)).! !!Parser methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:53'!esSimbolo: char|ret|"Verifica si el simbolo encontrado pertenece a la coleccion de prioridades"	colPrioridades detect: [:tupla| char= (tupla at: 1) ] ifFound:[ret:=true]  ifNone: [ ret:=false ].^ret! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Parser class	instanceVariableNames: ''!!Parser class methodsFor: 'as yet unclassified' stamp: 'Anonymous 1/29/2021 19:49'!crearParser: unaCadena	"comment stating purpose of message"	| parser |	parser:= self new.	parser inicializarParser: unaCadena.	^parser.! !!Parser class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 19:29'!crearParser	"comment stating purpose of message"	| parser |	parser:= self new.	parser inicializarParser.	^parser.! !OrderedCollection subclass: #Pila	instanceVariableNames: 'tope cantElem'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Pila methodsFor: 'as yet unclassified' stamp: 'Anonymous 1/29/2021 17:15'!extraerTope^tope.! !!Pila methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 13:12'!ponerEnPila: unElem	"Ingresa un elemento en la Pila"	||	self addLast: unElem.	cantElem := cantElem +1.	tope := unElem.! !!Pila methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 13:11'!inicializarPila	"Inicializa una pila"	||	tope := nil.	cantElem := 0.! !!Pila methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 15:21'!sacarTopePila	"Saca el tope de la Pila"	||	cantElem = 0 	ifTrue: [^'LA PILA YA ESTA VACIA']	ifFalse:[	self removeLast.		cantElem := cantElem -1.		cantElem > 0 ifTrue: [tope:= self at: cantElem] ifFalse: [tope:=nil].		]  ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pila class	instanceVariableNames: ''!!Pila class methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 1/26/2021 13:09'!crearPila	"Usa una ordered collection como Pila"	|pila|	pila := self new.	pila inicializarPila.	^pila.! !Operacion subclass: #Simple	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Simple methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/28/2021 18:55'!operarSimple: p1 simbolo: fun|sim|param1:=p1."dependiendo la funcion por parametro, hace una operación""si no se encuentra el programa hace una excepción"sim:= fun asSymbol. (fun = '!!') ifTrue: [ sim:= #factorial].resultado := param1 perform: sim.^resultado ! !!Simple methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 17:47'!inicializarSimpleself inicializarOperacion.resultado:= nil.colSimbolos add: 'cos'.colSimbolos add: 'sin'.colSimbolos add: 'tan'.colSimbolos add: '!!'.colSimbolos add: 'sqrt'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Simple class	instanceVariableNames: ''!!Simple class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/3/2021 14:13'!crearSimple: num funcion: fun|ret|ret:= self new.ret inicializarSimple: num funcion: fun.^ret.! !!Simple class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 10:24'!crearSimple |ret|ret:= self new.ret inicializarSimple.^ret.! !Object subclass: #Sistema	instanceVariableNames: 'valorX valoresX valorN cadena resultado intA intB colTuplas parser lector'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/18/2021 11:51'!setIntervaloB: num	intB:=num.	! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/18/2021 11:51'!setValorX: num	valorX :=num.	! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/8/2021 20:54'!getIntervaloB	^intB! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/8/2021 20:57'!getValorN	^valorN ! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/18/2021 11:51'!setIntervaloA: num	intA:=num.	! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/18/2021 11:51'!setValorN: num	valorN :=num.	 ! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/8/2021 20:56'!getValorX	^valorX ! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/8/2021 20:54'!getIntervaloA	^intA! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/8/2021 20:56'!getCadena	^cadena! !!Sistema methodsFor: 'initialization' stamp: 'Anonymous 2/8/2021 21:32'!setCadena: cad	cadena  :=cad.	self changed. ! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/13/2021 21:53'!getTuplas^colTuplas ! !!Sistema methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 3/3/2021 15:55'!evaluarEn: unValor"Evalua la funcion de entrada para un valor de x"	| rpn |	valorX:= unValor.rpn:= parser traducirCadena: cadena. "hacer que si ya esta calculado el rpn por haber hecho un intervalo, no se calcule de nuevo"lector setNotacionEntrada: rpn.lector añadirValorX: valorX.lector analizarNotacion.  lector getColResultados.resultado:= lector getColResultados at: 1.lector resetColecciones .! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/11/2021 00:55'!getColX	^valoresX ! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 20:55'!inicializarSistema   	cadena:=''.	parser:= Parser crearParser .	lector:= Lector crearLector. 				self changed.	! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/11/2021 00:56'!getColRes	^resultado! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 11:52'!convertirTuplas"Coloca en tuplas los valores de X e Y"|aux1 aux2|aux1 := valoresX collect: [ :char | { char . 0 } ].aux2 := resultado collect: [ : char | { 0 . char } ].colTuplas := aux1 + aux2.! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 21:18'!inicializarSistema: cad valorX:vx 		parser:= Parser crearParser .	lector:= Lector crearLector. 	cadena:= cad.	valorX:=vx.		self changed.	 	! !!Sistema methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/27/2021 21:18'!inicializarSistema: cad cantPuntos: vn intervaloDe: iA hasta: iB	parser:= Parser crearParser .	lector:= Lector crearLector. 	cadena:= cad.	valorN:= vn.	intA:= iA.	intB:= iB.	self changed.	! !!Sistema methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 3/3/2021 15:55'!obtenerResultadoMuchasX	| rpn |"traducimos la cadena a notacion rpn"rpn:= parser traducirCadena: cadena. "hacer que si ya esta calculado el rpn por haber hecho un calculo de un valor, no se calcule de nuevo"lector setNotacionEntrada: rpn.lector setCantPuntos: valorN.lector setValoresX: intA finIntervalo: intB. lector analizarNotacion.valoresX := lector getValoresX .resultado:= lector getColResultados.self convertirTuplas .lector resetColecciones .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Sistema class	instanceVariableNames: ''!!Sistema class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 19:20'!crearSistema: cad valoresX: valx valorN: valn	|ret|	ret:= self new.	ret inicializarSistema: cad valoresX: valx valorN: valn. 	^ret.! !!Sistema class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 20:22'!crearSistema: cad cantPuntos: n intervaloDe: iA hasta: iB	|ret|	ret:= self new.	ret inicializarSistema: cad cantPuntos: n intervaloDe: iA hasta: iB.	^ret.! !!Sistema class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/10/2021 11:00'!crearSistema	|ret|	ret:= self new.	ret inicializarSistema .	^ret.! !!Sistema class methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/4/2021 19:22'!crearSistema: cad valorX: valx 	|ret|	ret:= self new.	ret inicializarSistema: cad valorX: valx.  	^ret.! !BorderedMorph subclass: #VentanaInicio	instanceVariableNames: 'colRecuadros colBotones botonCerrar botonAtras texFuncion valorX resultadoValorX origen funcion cantPuntos inicioInter finInter intervalo grafico sis valorDeX colTup'	classVariableNames: ''	poolDictionaries: ''	category: 'TPO-FINAL-2021'!!VentanaInicio methodsFor: 'updating' stamp: 'Anonymous 2/14/2021 14:29'!update: unObjetounObjeto isNilifFalse: [ funcion  contents: (unObjeto getCadena).].! !!VentanaInicio methodsFor: 'initialization' stamp: 'Anonymous 2/18/2021 16:16'!abrirMenuPrincipal|rec bot1 bot2 bot3 texto1|rec:=(colRecuadros at:1). "recuadro sobre el texto"bot1:=(colBotones at:1). "boton de crear funcion"bot2:=(colBotones at:2). "boton de evaluar intervalo"bot3:= (colBotones at:3). "boton de evaluar valor X"self addMorph: rec.self addMorph: funcion. self addMorph: bot1. self addMorph: bot2.self addMorph: bot3.self addMorph: botonCerrar."posicionamos los morphs del menu principal"rec position: self position + (200@50).funcion position:rec position + (10@4). funcion color: Color black.bot1 position: rec position + (-90@0).bot2 position: self position + (50@200).bot2 bounds: (bot2 extent: 200@50).bot3 position: bot2 position + (300@0).bot3 bounds: (bot3 extent: 200@50).botonCerrar position: self position  + (555@0)."asignamos la acción de los botones"botonCerrar mouseAction: [self cerrar].bot1 mouseAction: [ self cambiarFuncion].bot2 mouseAction: [ funcion contents = '' ifTrue:[UIManager default alert: 'Ingrese una función'] ifFalse: [self removeAllMorphs. self abrirEvaluarIntervalo]].bot3 mouseAction: [ funcion contents = '' ifTrue:[UIManager default alert: 'Ingrese una función'] ifFalse: [self removeAllMorphs. self abrirEvaluarValorX ]].! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:15'!cerrar"cierra la pantalla"self delete.! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 2/16/2021 14:36'!ponerCantPuntos	"Establece una cantidad de puntos"	|var|	var := (UIManager default ) request: 'Ingrese la cantidad de puntos:'.	[var isEmpty] whileTrue: [var := (UIManager default ) request: 'ERROR: Ingrese la cantidad de puntos:'.].	sis setValorN: var asNumber.	cantPuntos contents: var.! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:15'!colocarBotonesAux"metodo para colocar los botones cerrar y atras en la ventana principal"self addMorph: botonCerrar.self addMorph: botonAtras.botonAtras position: self position .botonCerrar position: self position + (555@0).! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/17/2021 17:59'!resolverValorX"resolvemos la ecuacion con los datos que tenemos"sis evaluarEn: valorDeX.resultadoValorX contents: 'Resultado: ', sis getColRes asString .! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:41'!abrirGraficador|window scrollPane pasteUpMorph ejeX ejeY i aux n c coor cond ex valorEjeX valorEjeY intx inty|sis obtenerResultadoMuchasX. "Llamamos al metodo del sistema que nos da todos los resultados"colTup := sis getTuplas.	"obtenemos las tuplas"ex := 0. "ex es la extension que tendra el fondo, y de donde se basan las coordenadas del grafico"colTup do: [ :char1 | ex:= ex max: (((char1 at: 1)abs) max: ((char1 at: 2)abs))].ex:= ex rounded . valorEjeX := (1+ex)*(-1). "valor que va a tener el punto posicionado sobre el eje X"valorEjeY := 1+ex. 		"valor que va a tener el punto posicionado sobre el eje Y"ex := (((ex*50)*2)+200)."creamos la ventana externa"window := SystemWindow new.scrollPane := ScrollPane new.pasteUpMorph := PasteUpMorph new.pasteUpMorph extent: ex@ex.scrollPane scroller addMorph: pasteUpMorph.window addMorph: scrollPane frame: (0@0 corner: 1@1).                              "creo el eje X e Y"ejeX := (LineMorph from: 0@(ex/2)+4 to: ex@(ex/2)+4 color: Color black width: 3).ejeY := (LineMorph from: (ex/2)+4@0 to: (ex/2)+4@ex color: Color black width: 3).i:=ex/50.n:=0.[ i>0 ] whileTrue: [	"puntos en eje X"	             aux := CircleMorph new. aux color: Color black. aux extent: 9@9. aux position: (n+50)@(ex/2).					intx := StringMorph new contents: (valorEjeX asInteger)asString.					intx position: (n+50)@((ex/2)+10).					 pasteUpMorph addMorph: (intx color: Color black). "se agrega el numero del punto"					 	             pasteUpMorph addMorph: aux. "se agrega el punto"	"puntos en eje Y"	             aux := CircleMorph new. aux color: Color black. aux extent: 9@9. aux position: (ex/2)@(n+50).					inty := StringMorph new contents: (valorEjeY asInteger)asString.					inty position: ((ex/2)+10)@(n+50).					pasteUpMorph addMorph: (inty color: Color black).	            pasteUpMorph addMorph: aux.					valorEjeX := valorEjeX +1.					valorEjeY := valorEjeY -1.	             n:=n+50.	             i:=i-1.	     ].pasteUpMorph addMorph: ejeX.pasteUpMorph addMorph: ejeY."zona donde se crea el grafico de la funcion"cond := false.colTup do: [ :char | "Creacion de puntos"   n := (((char at: 1)*(50))+(ex/2)).   aux := ((char at: 2)*(-50)+(ex/2)).	(cond)ifFalse: [ 		coor := n@aux+4.	].	c := CircleMorph new. "se crean los circulos rojos que indica el punto (x1,y1)"	c extent: 8@8. 	c color: Color red. 	c position: n@aux. 	pasteUpMorph addMorph: c.	"Creacion de rectas"	(cond)ifTrue: [  "condicion para evitar crear una linea en la primer creacion de puntos."		c := LineMorph from: coor to: (n+4)@(aux+4) color: Color black width: 2. 		pasteUpMorph addMorph: c. 		coor := (n+4)@(aux+4).	].	cond := true.]."fin zona"window openInWorld.! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:08'!cambiarFuncion	"metodo para cambiar la funcion principal"	| string |		string:= (UIManager default ) request: 'Ingrese una funcion:'.	sis setCadena: string.	! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:08'!verificarDatosGrafico"condiciones previas para que no haya errores en el grafico"|ret|ret:=true.sis getIntervaloA isNil ifTrue:[UIManager default alert: 'colocar valor del intervalo a: [a,b]'. ret:=false].sis getIntervaloB isNil ifTrue:[UIManager default alert: 'colocar valor del intervalo b: [a,b]'. ret:=false].sis getValorN isNil ifTrue:[UIManager default alert: 'falta colocar la cantidad de puntos'. ret:=false].ret ifTrue:[sis getIntervaloA >= sis getIntervaloB ifTrue:[UIManager default alert:'El intervalo esta mal escrito: [a,b] a<b siempre'. ret:=false]].^ret.! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:14'!inicializarBotonesyRecuadros"se inicializan todos los botones y los recuadros que van a aparecer por pantalla"colBotones := OrderedCollection new.8 timesRepeat: [colBotones add: BotonAccion2 new].(colBotones  at: 1) label: 'Crear funcion'.(colBotones  at: 2) label: 'Evaluar intervalo'.(colBotones  at: 3) label: 'Evaluar valor X'.(colBotones  at: 4) label: 'Colocar intervalo:'.(colBotones  at: 5) label: 'Colocar cantidad de puntos:'.(colBotones  at: 6) label: 'Graficar'.(colBotones  at: 7) label: 'Colocar valor X'.(colBotones  at: 8) label: 'Resolver'."se crean los botones para cerrar e ir para atras"botonCerrar := BotonAccion2 new.botonCerrar label: 'Cerrar'. botonCerrar color: Color red.botonAtras:= BotonAccion2 new.botonAtras label: 'Atras'."se cargan los recuadros que estan por detras de los datos que aparecen por pantalla"colRecuadros := OrderedCollection new.3 timesRepeat: [colRecuadros  add: BorderedMorph new].colRecuadros do:[	:rec| rec position: origen.								rec color: Color paleYellow.								rec bounds:  (rec position extent: 200@25)].! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/17/2021 17:59'!ponerValorX		"establecemos que valor va a tener X"	| val|	val:=(UIManager default ) request: 'Ingrese un valorX:'.		[val isEmpty] whileTrue: [val := (UIManager default ) request: 'ERROR: Ingrese un valorX'.].	valorDeX := val asNumber.		valorX contents: val.! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 2/16/2021 14:25'!ponerIntervalo	"Establece un intervalo"	|ini fin|	ini := (UIManager default ) request: 'Ingrese inicio de intervalo:'.	[ini isEmpty] whileTrue: [ini := (UIManager default ) request: 'ERROR: Ingrese inicio de intervalo:'.].	fin := (UIManager default ) request: 'Ingrese fin de intervalo:'.	[fin isEmpty] whileTrue: [fin := (UIManager default ) request: 'ERROR: Ingrese fin de intervalo:'.].	sis setIntervaloA: ini asNumber.	sis setIntervaloB: fin asNumber.		intervalo contents: '[',ini,',',fin,']'.				! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 2/16/2021 13:47'!abrirEvaluarIntervalo	|botInt botCantP recInt recCantP recF graficar|		self colocarBotonesAux.									"se cargan los botones auxiliares"		intervalo:= StringMorph new contents: ''.			"muestra por pantalla el intervalo"	cantPuntos := StringMorph new contents:''.			"muestra por pantalla la cantidad de puntos"			botInt:= colBotones at:4.								"boton que indica la modificacion del intervalo"	botCantP := colBotones at:5.							"boton que indica la modificacion de la cantidad de puntos"	graficar:= colBotones at:6.								"boton que da inicio al grafico"	recInt:= colRecuadros at: 1.							"recuadro donde va el intervalo en la pantalla"	recCantP := colRecuadros at: 2.						"recuadro donde va la cantidad de puntos"	recF := colRecuadros at: 3.								"recuadro donde va la funcion"		"colocamos los morphs"	self addMorph: botInt.	self addMorph: botCantP.	self addMorph: graficar.	self addMorph: recInt .	self addMorph: recCantP.	self addMorph: recF. 	self addMorph: funcion.	self addMorph: intervalo. 	self addMorph: cantPuntos.	self addMorph: funcion.	"self addMorph: texFuncion."		"los posicionamos"	recF position: self position + (200@50).	funcion position:recF position + (10@4).	recInt position: recF position + (0@50).	botInt position: recInt position + (-150@0).	recCantP position: recInt position + (0@50).	botCantP position: recCantP position + (-200@0).	graficar position: recCantP position + (0@50). 	intervalo position: recInt position+(10@4). intervalo color: Color black.	cantPuntos position: recCantP position + (10@4). cantPuntos color: Color black.	graficar bounds: (graficar extent: 200@50).	graficar color: Color blue.		"-----------------------------------------------------------------------"	"colocamos la accion de los botones"	botInt mouseAction: [ self ponerIntervalo].	botCantP mouseAction: [ self ponerCantPuntos].	botonAtras mouseAction: [ self removeAllMorphs. self abrirMenuPrincipal].	graficar mouseAction: [ [ self verificarDatosGrafico ]value ifTrue:[self abrirGraficador  ]].! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'LeandroVallejos 2/16/2021 13:39'!initializesuper initialize.self color: Color gray.self position: 45@45.self bounds: (self position extent: 600@300).origen := self innerBounds origin.sis:= Sistema crearSistema.funcion:= StringMorph new. "texFuncion := StringMorph new.""texFuncion position: self position + (250@250).""dependencias"sis addDependent: self.self update: sis.self inicializarBotonesyRecuadros.self abrirMenuPrincipal .! !!VentanaInicio methodsFor: 'as yet unclassified' stamp: 'Anonymous 2/18/2021 16:08'!abrirEvaluarValorX|botValorX botResolver recF recValorX recResolver|self colocarBotonesAux.valorX:= StringMorph new contents: ''.								"muestra por pantalla el valor que se le va a dar a x"resultadoValorX := StringMorph new contents: ''.					"muestra por pantalla el resultado de la ecuacion"botValorX := colBotones at:7.											"boton para modificar el valor que se le va a dar a x"botResolver := colBotones at:8.										"boton para ver el resultado"recF:= colRecuadros at:1.recValorX:= colRecuadros at:2.recResolver := colRecuadros at:3."agregamos los morphs"self addMorph: recF. self addMorph: funcion.self addMorph: botValorX .self addMorph: botResolver .self addMorph: recValorX .self addMorph: recResolver.self addMorph: valorX.self addMorph: resultadoValorX ."posicionamos los morphs"recF position: self position + (200@50).funcion position:recF position + (10@4).recValorX position: recF position + (0@50).botValorX position: recValorX position + (-150@0).recResolver  position: recValorX  position + (0@50).botResolver  position: recResolver  position + (-150@0).valorX position: recValorX position + (10@4). valorX color: Color black.resultadoValorX  position: recResolver position + (10@4). resultadoValorX color: Color black."Accion de los botones"botValorX mouseAction: [ self ponerValorX  ].botResolver mouseAction: [ valorDeX isNil ifTrue:[UIManager default alert: 'Colocar valor de X'] ifFalse: [self resolverValorX]  ].botonAtras mouseAction: [ self removeAllMorphs. self abrirMenuPrincipal].! !